// Реализуем код, находящий самого взрослого пользователя:
const users = [
    { name: 'Igor', age: 19 },
    { name: 'Danil', age: 1 },
    { name: 'Vovan', age: 4 },
    { name: 'Matvey', age: 16 },
  ];
  
  let oldest = users[0];
  for (const user of users) {
    if (user.age > oldest.age) {
      oldest = user;
    }
  }
/*Основное отличие агрегации от отображения и фильтрации в том, что результатом агрегации может 
быть любой тип данных — как примитивный так и составной, например, массив. */


const oldest = users.reduce(
    (acc, user) => user.age > acc.age ? user : acc, // callback-функция
    users[0], // аккумулятор (начальное значение)
  );
  
  console.log(oldest); // => { name: 'Igor', age: 19 }

/*Метод reduce принимает на вход два параметра — функцию-обработчик (callback) и начальное значение 
аккумулятора. Поиск самого взрослого пользователя аналогичен поиску максимального (или минимального) 
числа в массиве. Соответственно, аккумулятор должен быть инициализирован первым пользователем. 
Этот же аккумулятор возвращается наружу. */

/*Callback-функция, передаваемая в reduce — самая важная часть и ключ к пониманию работы всего механизма 
агрегации. Она принимает на вход два значения. Первый — текущее значение аккумулятора, второй — текущий 
обрабатываемый элемент. Задача функции — вернуть новое значение аккумулятора. reduce никак не анализирует 
содержимое аккумулятора. Всё, что он делает, передаёт его в каждый новый вызов до тех пор, пока не будет 
обработана вся коллекция, и в конце концов вернёт его наружу. Подчеркну, что возвращать аккумулятор 
надо всегда, даже если он не изменился. */

// // предварительно подготовим callback-функцию
import _ from 'lodash'; // типа импорт(по факту это просто пример)
const cb = (acc, {age, name}) => {
    if (_.has(acc, age)) {
        acc[age].push(name);
  } else {
    acc[age] = [name];
  }
  return acc;
};  

const usersByAge = users.reduce(cb, {});
