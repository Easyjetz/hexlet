/*В языках программирования существует понятие "объекты первого рода (или класса)". 
Им обозначают элементы, которые могут быть переданы в функции, возвращены из функций и 
присвоены переменным (или константам). К таким элементам относятся любые данные, например числа, 
строки, массивы или логические значения. */

// 5 — число, объект первого рода (сохранено в константе)
const num = 5;

// 2 — число, объект первого рода (аргумент функции)
// содержимое константы num — объект первого рода (аргумент функции)
// содержимое константы result — объект первого рода (возвращаемое значение)
const result = Math.pow(num, 2);

// Функции тоже могут быть объектами первого рода.

// Cохранение в переменной
const x = () => console.log('hey');

x(); // => hey

// в этом коде не создается функция x, здесь происходит следующее:

// 1. Создание (определение) функции: () => console.log('hey')
// 2. Создание константы x и сохранение в ней значения в виде функции: const x =

/*говоря "сохранили функцию в переменной" подразумеваем "сохранили ссылку на функцию в переменной".*/

let a = () => console.log('hey');

a(); // => 'hey'

// перезаписали переменную другим значением — числом 10,
// теперь 'a' содержит число, а доступ к функции утерян
a = 10;

// если а переменная, а не константа мы можем спокойно изменить её значение и потерять доступ к функции

// Мы даже можем пересохранить функцию в другой константе:

const a = () => console.log('hey');

a(); // => 'hey'

const b = a;

b(); // => 'hey'

// Более того, анонимную функцию можно использовать напрямую, без сохранения в константе:

(() => console.log('hey'))(); // => hey

/*Таким образом, имя переменной, содержащей функцию, не является именем функции. 
Поэтому такие функции и называются "анонимными". В других языках анонимные функции нередко называют 
лямбда-функциями. В принципе, и в JavaScript их иногда зовут так же. */

// Создание внутри другой функции

const sum = (a, b) => {
    // определили "внутреннюю" анонимную функцию и
    // сохранили в константе innerSum
    const innerSum = (x, y) => x + y;
  
    // вызвали внутреннюю функции и
    // вернули результат вызова наружу из sum
    return innerSum(a, b);
  };
  
  sum(1, 4); // 5