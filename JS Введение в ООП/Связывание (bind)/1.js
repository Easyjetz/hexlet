const printer = {
    name: 'Hexlet',
    print(greeting = 'hello') {
      console.log(`${greeting}, ${this.name}`);
    }
};
  
// Хотим запустить метод print через секунду
setTimeout(printer.print, 1000);

/*
Этот код выдаст hello, undefined. Потому что внутрь setTimeout мы передали не объект printer, 
а функцию print без объекта. А значит эта функция потеряла связь с самим объектом и ее this больше не 
указывает на объект. Вот так можно проиллюстрировать то, что происходит:
*/

const print = printer.print;
print(); // => hello, undefined

// Если контекста нет, то this оказывается равным пустому объекту в случае обычной функции и undefined 
// в случае стрелочной.

/*
Такое поведение часто нежелательно. Практически всегда, когда передается метод, подразумевается, что он 
будет вызван в контексте того объекта, которому он принадлежит. Существует несколько способов добиться 
такого поведения. Самый простой — обернуть функцию в функцию, пока мы вызываем функцию. 
*/

setTimeout(() => printer.print(), 1000);
// "hello, Hexlet"

/*
Другой способ — использование метода bind (переводится как связывание). Метод bind доступен у функций, 
и в его задачу входит связывание функции с каким-то контекстом. Контекст передается в нее первым 
параметром.
*/

// Контекстом является тот же объект, в котором определен метод
// Это довольно странно выглядит, но жизнь сложная штука

const bindedPrint = printer.print.bind(printer);

// Теперь можно так 
bindedPrint(); // => "hello, Hexlet"
setTimeout(bindedPrint, 1000);
// Можно вызывать bind прямо по месту
setTimeout(printer.print.bind(printer), 1000);
// "hello, Hexlet"

/*
Кроме контекста, bind принимает на вход параметры, которые нужны функции. Причем не сразу все, а любую их 
часть. bind подставит их в новую функцию (та, что вернется из метода bind) "частично".
*/

setTimeout(printer.print.bind(printer, 'hi'), 1000);
"hi, hexlet"

// Подход с bind был популярен до появления стрелочных функций, сейчас его используют нечасто, и по 
// возможности стоит его избегать. Стрелочные функции проще для понимания и используются повсеместно.

// Apply && Call

// func.apply(thisArg, [ argsArray])
const print = printer.print;
print.apply(printer, ['hi']); // "hi, hexlet"

// func.call([thisArg[, arg1, arg2, ...argN]])
print.call(printer, 'hi'); // "hi, hexlet"

/*
Эти функции внутри себя делают две вещи, меняют контекст и сразу же производят вызов функции. 
Разница лишь в том, как они работают с аргументами этих функций: apply – принимает аргументы в виде 
массива вторым параметром, а call, ждет на вход позиционные аргументы.
*/