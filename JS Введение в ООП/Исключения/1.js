/* главная цель — передать ошибку из того места, где она возникла, в место, где её можно обработать, 
минуя все промежуточные уровни. Другими словами, механизм исключений раскручивает стек вызовов 
самостоятельно. */

/* 
С исключениями нужно запомнить две вещи: код, в котором произошла ошибка, выбрасывает исключение,
а код, в котором ошибка обрабатывается – её ловит.
*/

// Функция, которая может выбросить исключение
const readFile = (filepath) => {
    if (!isFileReadable(filepath)) {
      // throw – способ выбросить исключение
      throw new Error(`'${filepath}' is not readable`);
    }
    // ...
  }
  
  // Где-то в другом месте программы
  
  const run = (filepath) => {
    try {
      // Функция, которая вызывает readFile. Возможно не напрямую, а через другие функции.
      // Для механизма исключений это не важно.
      openFile(filepath);
    } catch (e) {
      // Этот блок выполняется только в одном случае, если в блоке try было выброшено исключение
      showErrorToUser(e);
    }
    // Если тут будет код, он продолжит выполняться
}

/* Сами исключения – это объекты Error. Эти объекты содержат внутри себя сообщение, переданное в 
конструктор, трассировку стека и другие полезные данные:

Самостоятельно исключение выбрасывается с помощью ключевого слова throw: */

const e = new Error('Тут любой текст');
throw e; // Исключение можно создать отдельно, а можно сразу же там, где используется throw

/*
throw прерывает дальнейшее выполнение кода. В этом смысле оно подобно return, но в отличие от него,
прерывает выполнение не только текущей функции, но и всего кода, вплоть до ближайшего в стеке вызовов 
блока catch.

Блок try/catch обычно ставится на самом верхнем уровне программы, но это не обязательно. Вполне вероятно, 
что есть несколько промежуточных блоков, которые могут отлавливать ошибки и снова их возбуждать. 
Эта тема достаточно сложная и требует некоторого опыта работы.
*/