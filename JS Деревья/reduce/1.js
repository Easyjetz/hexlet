const reduce = (f, tree, acc) => {
    const [, children] = tree;
    const newAcc = f(acc);
  
    if (!children) {
      return newAcc;
    }
    return children.reduce((iAcc, n) => reduce(f, n, iAcc), newAcc);
};
  
  const tree = ['A', [
    ['B', [['E'], ['F']]],
    ['C'],
    ['D', [['G'], ['J']]],
]];
  
reduce((acc) => acc + 1, tree, 0); // 8

/*
Выше пример теста, в котором используется reduce для подсчёта количества узлов в дереве. 
С помощью reduce, задача выполняется в одну строку.

Так же как и в остальных функциях высшего порядка, в функцию-обработчик передаётся нода целиком, 
а не только имя. Самое интересное происходит при обработке детей. Вызов reduce на каждом ребёнке должен 
происходить с аккумулятором, протаскиваемым сквозь обработку каждого ребёнка. Из-за этого получается что 
снаружи есть reduce перебирающий children, в то время как каждый ребёнок принимает на вход текущий acc 
внешнего reduce и запускает внутренний с этим аккумулятором.
*/