/* Любой код, использующий точки или отрезки, знает о том, как они устроены внутри. 
Это относится как к коду, который создаёт новые примитивы, так и к коду, который извлекает из них 
составные части. Изменить ситуацию и спрятать реализацию достаточно просто, используя функции:
*/

const point = makeDecartPoint(3, 4);
const symmetricalPoint = makeDecartPoint(-getX(point), getY(point));
/* В примере мы видим три функции makeDecartPoint, getX и getY. Функция makeDecartPoint называется 
конструктором, потому что она создаёт новый примитив, функции getX и getY — селекторами (selector), 
от слова "select", что в переводе означает "извлекать" или "выбирать". Такое небольшое изменение ведёт к 
далеко идущим последствиям. Главное, что в прикладном коде (том, который использует библиотеку)
отсутствует работа со структурой напрямую. */


// То есть мы работаем не так
const point = [1, 4]; // мы знаем что это массив
console.log(point[1]); // прямое обращение к массиву

// А так
const point = makeDecartPoint(3, 4); // мы не знаем как устроена точка
console.log(getY(point)); // мы получаем доступ к частям только через селекторы

/*
Глядя на код, даже нельзя сказать, что из себя представляет точка "изнутри", какими конструкциями языка 
представлена (для этого можно воспользоваться отладочной печатью). Так мы построили абстракцию данных. 
Суть этой абстракции заключается в том, что мы скрываем внутреннюю реализацию. Можно сказать, что создание 
абстракции с помощью данных приводит к сокрытию этих данных от внешнего кода.

А вот один из способов реализовать абстракцию для работы с точкой:
*/
const makeDecartPoint = (x, y) => ({ x: x, y: y });

const getX = (point) => point['x'];
const getY = (point) => point['y']; 

/* 
Начав однажды работать через абстракцию данных, назад пути нет. Придерживайтесь всегда тех функций, 
которые вы создали сами. Либо тех, которые вам предоставляет используемая библиотека.
*/