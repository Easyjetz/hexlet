// Автоматические тесты

/*Всё, что требуется от автоматических тестов — повторить проверки, которые мы выполняли, 
делая ручное тестирование. Для этого достаточно старого доброго if и исключений. */

/*ошибки можно порождать самостоятельно с помощью исключений, что необходимо для нашей ситуации. 
Исключения создаются такой конструкцией: */

throw new Error('описание исключения');
// Код, следующий за этим выражением, не выполнится, а сам скрипт завершится с ошибкой
console.log('nothing');

// Пример теста:

if (capitalize('hello') !== 'Hello') {  // Если результат функции не равен ожидаемому значению
    // Выбрасываем исключение и завершаем выполнение теста
    throw new Error('Функция работает неверно!');
}

/*В коде, тесты, как правило, складывают в специальную директорию в корне проекта. 
Обычно она называется tests, хотя встречаются и другие варианты: */

/*
src/
├── bin
│   └── hexlet.js
├── half.js
└── index.js
tests/
└── half.test.js
*/

// Как пишутся тесты

// Сколько и какие нужно писать проверки?
// проверяем какой-нибудь очевидный результат работы функции, если срабатывает
// Нужно смотреть на "пограничные случаи". Это ситуации, в которых код может повести себя по-особенному:
/*
Работа с пустой строкой
Обработка null
Деление на ноль (в большинстве языков вызывает ошибку)
Специфические ситуации для конкретных алгоритмов
 */

// Для capitalize пограничным случаем будет пустая строка:

if (capitalize('') !== '') {
  throw new Error('Функция работает неверно!');
}

// Проверка входных данных

/*Особняком стоят ошибки типов входных данных. Например, в функцию capitalize можно передать число вместо 
строки. Как она должна себя вести в таком случае? Нужно ли писать такой тест?

Ещё один интересный вопрос. Нужно ли внутри capitalize обрабатывать такие ситуации? 
Ответ — не нужно. Иначе код превратится в мусорку, а пользы от этого мало. Всё равно должны быть тесты, 
которые проверяют, что система работает в целом, а они обычно выявляют проблемы кода на более нижних 
уровнях.

Ответственность за передачу правильных данных в функцию capitalize лежит не на ней, а на коде, 
который вызывает эту функцию. И если он хорошо протестирован, то подобная ошибка либо обнаружится, 
либо вообще не возникнет. */