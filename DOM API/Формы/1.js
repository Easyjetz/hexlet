/*
В современных фронтенд приложениях существует два подхода при работе с формами. В некоторых, 
изменение данных на странице происходит сразу по мере изменения формы. У такой формы нет кнопки 
"сохранить" или "отправить". Здесь каждый элемент формы связан с обработчиком, который отслеживает 
любые изменения. Типичный пример – фильтрация данных на странице.
*/

// В более классическом варианте отправка формы происходит по кнопке. В таком случае нужно использовать 
// событие submit самой формы.

const form = document.querySelector(/* селектор до формы */);
form.addEventListener('submit', (e) => {
   // Если хотим работать с формой через javascript, то нужно остановить отправку (действие по умолчанию)
  e.preventDefault();
  // что-то делаем
});

/*
Некоторые разработчики отправляют формы не по событию submit, а по клику на кнопке отправки формы. 
Так делать не нужно
*/

/*
Сама обработка формы строится обычно так (упрощенно):

Извлекаются данные формы
Выполняется запрос на сервер / Меняются данные в приложении
Изменяется внешний вид
*/

/*
Второй и третий пункт мы рассмотрим в следующих уроках, когда поговорим про Ajax, а здесь поговорим о 
первом. О том как получить данные формы.
*/

// Существует два подхода: правильный и неправильный. Сначала неправильный:

const input = document.querySelector(/* селектор до поля ввода */); 
form.addEventListener('submit', (e) => {
  e.preventDefault();
  const { value } = input;
  // Что-то делаем с данными
});

/*
При таком подходе придется работать с каждым элементом формы индивидуально. Сначала извлечь их из DOM, 
затем собрать значения. Делать так не нужно, потому что есть правильный способ.
*/

// Правильный способ – использовать специальный объект FormData доступный в браузере:
/*
<form method="post">
  <input name="email" value="example@example.com">
  <input name="password" value="supersecret">
  <input type="submit" value="Sign Up">
</form>
*/


const form = document.querySelector(/* селектор нужной формы */);
form.addEventListener('submit', (e) => {
    e.preventDefault();
    // Данные формы извлекаются из DOM автоматически 
    const formData = new FormData(e.target); // На вход передается элемент формы взятый из события!
    // Теперь с ними можно работать
    formData.get('email'); // example@example.com
    // values() возвращает итератор, поэтому преобразуем в массив
    [...formData.values()]; // ['example@example.com', 'supersecret']
    // Тоже итератор
    [...formData.entries()]; // [['email', 'example@example.com'], ['password', 'supersecret']]
  
    // Преобразование в обычный объект
    Object.fromEntries(formData); // { email: 'example@example.com', password: 'supersecret' }
});

// Извлечение элементов формы

/*
Иногда, все же, приходится обращаться к элементам формы напрямую. Например при реализации валидации во 
время изменения формы, а не ее отправки. В таких случаях, работа с элементами формы идет напрямую:
*/

const input = document.querySelector(/* селектор до поля ввода */); 
input.addEventListener('change', (e) => {
  // Логика
});

/*
Если элементов много, то код, выполняющий запросы в DOM, станет громоздким. Этого можно избежать если 
использовать возможности DOM относящиеся к формам. Каждая форма, содержит свойство elements, которое 
возвращает объект cо всеми элементами данной формы. Ключи объекта – имена элементов, значения – сами 
элементы.
*/

const form = document.querySelector(/* селектор до формы */);
form.elements.email // <input name="email" ...
form.elements.password // <input name="email" ...

// Обработка
form.elements.email.addEventListener('change', () => {
  // Обработка
});

